\chapter{\textit{Software Deskworld}}
\label{cap5}

Neste capítulo é apresentado o \textit{Design} do \textit{Software Deskworld}, seus detalhes de implementação, sua arquitetura e a estrutura utilizada para implementar o simulador.

\section{\textit{Design} do \textit{Deskworld}}
\label{cap5.1}

Nesta seção, apresenta-se o \textit{Design} do \textit{Software}, isto é, o projeto de sua aplicação com as características expressas em uma visão computacional de alto nível, ou seja, a nível de usuário.

\subsection{Requisitos de interface}
\label{cap5.1.1}

De maneira simplificada, esses requisitos podem ser expressos da seguinte forma:
\begin{itemize}
	\item Sua mecânica deve permitir a participação de diversos jogadores simultaneamente.
	\item Suportar e processar toques simultâneos.
	\item Capacidade de aproximar formas.
\end{itemize}

\subsection{Conceito}
\label{cap5.1.2}
O simulador de física \textit{Deskworld} tem como principal proposta deixar a cargo da criatividade do(s) usuário(s) a construções de cenários, objetos e seus respectivos objetivos neste mundo virtual. O principal objetivo é prover ferramentas aos usuários, auxiliando-os nessa construção. Assim, objetos e elementos físicos são representados em um plano bidimensional, regidos pelas leis da física. É possível desenhar um objeto e associá-lo a algum tipo de elemento, de acordo com suas propriedades tais como massa, coeficiente de atrito e elasticidade. O usuário pode aplicar uma força a este objeto como a gravidade, fixá-lo no plano, entre outras opções. Pode, ainda, mudar as propriedades do mundo em que se encontra e, sem interrupções, dividi-lo, criando novos submundos para usá-los separadamente.

\subsection{Regras e Objetos}
\label{cap5.1.3}
Basicamente, pode-se criar qualquer tipo de objeto 2D, com ou sem o auxílio das ferramentas fornecidas. A construção funciona similarmente ao desenho virtual, onde o dedo representa o lápis e a superfície da mesa, o papel.

Cada objeto pode ter as seguintes características:
\begin{itemize}
	\item Densidade
	\item Coeficiente de atrito
	\item Coeficiente de restituição de força
	\item Força normal
	\item Massa
	\item Volume
	\item Velocidade
\end{itemize}

Dessas características, a densidade, o coeficiente de atrito, o coeficiente de restituição de força e a massa podem ser alterados pelo usuário a qualquer momento.

Além dessas propriedades, os objetos podem interagir entre si por meio de juntas, colisões ou motores adicionados aos objetos. Também é possível a separação de mundos com gravidades diferentes e cores de pincéis diferentes entre si. As juntas são entidades que permite fixar um objeto a outro. Funciona, analogamente, a colocar um prego para juntar dois pedaços de madeira.

Neste simulador não existe uma regra pré-definida, pois pode ser definida pontualmente por um usuário, ao criar um cenário e objetos.

\subsection{Interface}
\label{cap5.1.4}
A interface utilizada para testes é a mesa descrita no capítulo~\ref{cap4}. Porém, o jogo é portável para qualquer interface multi-toque que suporte o protocolo \textit{TUIO}.

\section{Ferramentas de suporte do simulador}
\label{cap5.2}

Nesta seção, serão descritas as ferramentas de suporte utilizadas na construção do simulador.

\subsection{\textit{Game Engine}}
\label{cap5.2.1}

A \textit{engine} utilizada neste \textit{software} foi a \textit{Box2D}. Seu manual pode ser encontrado em~[\citenum{Box2Dmanual}]. A principal funcionalidade da \textit{Box2D} no contexto desse \textit{software} foi auxiliar na criação dos objetos e no tratamento de eventos relacionados à simulação das leis da física. Estes eventos estão apresentados a seguir.

\begin{itemize}
	\item Gravidade
	\item Colisão
	\item Força de ação e reação
	\item Força de atrito
\end{itemize}

Além dessas funcionalidades, a \textit{Box2D} é responsável pela gerência de memória, junção de objetos e/ou a fixação deles.

\subsection{\textit{Bibliotecas de apoio}}
\label{cap5.2.2}

Para facilitar a implementação do \textit{software}, foram utilizadas diversas bibliotecas. Uma das bibliotecas padrão do C++, a \textit{STL} \textit{(Standart Template Library)}, possui algumas estruturas complexas de dados já implementadas, sendo amplamente utilizada neste simulador. Para a parte gráfica do jogo foi utilizada a biblioteca \textit{SDL} \textit{(Simple Direct Layer)} conjuntamente com a \textit{OpenGL} (\textit{Open Graphics Library}). Com relação ao áudio, utilizou-se a biblitoca \textit{SDL\_mixer}. Para tratamento de \textit{input} foi utilizada a biblioteca do protocolo \textit{TUIO} (\textit{Tangible User Interface System}).

\subsubsection{\textit{SDL} e \textit{OpenGL}}
\label{cap5.2.2.1}

Por oferecer uma boa abstração de \textit{hardware}, ser bem difundida no mercado de jogos e possuir ampla documentação, utilizou-se a \textit{SDL} para disponibilizar o acesso ao ambiente. Conjuntamente com a \textit{SDL}, na parte gráfica, foi utilizada a \textit{OpenGL} (\textit{Open Graphics Library}), que realiza a renderização das imagens.

A \textit{SDL\_mixer} é utilizada para permitir a reprodução de diversas faixas de áudio simultaneamente.

\subsubsection{Protocolo \textit{TUIO}}
\label{cap5.2.2.2}

A comunicação entre o usuário da mesa e o aplicativo é realizada de acordo com o protocolo \textit{TUIO}~[\citenum{TUIO}] (\textit{Tangible User Interface System}). Este protocolo é especificado para atender as necessidades de comunicação das interfaces tangíveis, que são interfaces sensíveis ao toque, capazes de serem controladas por movimentos corporais e gestos. A implementação é simples e visa melhorar a performance na comunicação. Para isso, ele opera sobre a camada \textit{UDP}(\textit{User Datagram Protocol}) de transporte utilizando três tipos de mensagens: \textit{set}, \textit{alive} e \textit{fseq}. As mensagens \textit{set} são utilizadas para informar o estado de um objeto. Mensagens \textit{alive} indicam o conjunto de objetos presentes na interface através de uma identificação única atribuída a cada novo elemento reconhecido. Mensagens \textit{fseq} são transmitidas antes da etapa de atualização de cada quadro, para marcá-lo unicamente, associando-o a cada mensagem \textit{set} e \textit{alive}. A seguir é apresentado um  resumo do funcionamento do protocolo:

\begin{itemize}
	\item Parâmetros do objeto são enviados após mudança de estado, por intermédio da mensagem \textit{set}.
	\item Objetos removidos da interface são comunicados por meio de mensagens \textit{alive}.
	\item Cliente deduz a lista de objetos adicionados e removido por meio das mensagens \textit{set} e \textit{alive}.
	\item Mensagens \textit{fseq} associam um ID a um conjunto de mensagens \textit{set} e \textit{alive} do quadro.
\end{itemize}

Apesar da camada UDP de transporte não oferecer garantia de entrega dos dados, o TUIO implementa redundância de informação para se precaver contra a perda de dados na transmissão. Além disso, o estado de um objeto, mesmo inalterado, é enviado periodicamente em uma mensagem \textit{set}. Portanto, o protocolo é ideal para ser utilizado em aplicativos controlados por interfaces multitoque, otimizando a interação e confiabilidade da comunicação.

\textbf{\large{Parâmetros das mensagens TUIO}}

\begin{table}[htbp]
  \centering
  	\caption{Parâmetros de mensagens TUIO em superfícies interativas 2D}
    \begin{tabular}{|l|l|l|} %rrr}
    \textbf{Parâmetros} & \textbf{Significado dos parâmetros} & \textbf{Tipo} \\
    s     & sessionID (ID temporário do objeto) & int32 \\
    x, y  & posição & float32 \\
    X, Y  & vetor de movimento (velocidade de movimento e direção) & float32 \\
    m     & aceleração de movimento & float32 \\
    w, h  & largura e altura do \textit{blob} & float32 \\
    \end{tabular}%
  \label{tab:tabela1_param_TUIO}%
\end{table}%

\subsubsection{\textit{Community Core Vision}}
\label{cap5.2.3}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.4]{ccv.jpg}
	\caption{Aplicativo de captura de toques \textit{Community Core Vision}~[\citenum{ccv}]}
	\label{ccv}
	\end{center}
\end{figure}

O \textit{CCV} (\textit{Community Core Vision})~[\citenum{ccv}] é um aplicativo para auxiliar o processamento de imagens capturadas pela câmera em interações com superfícies multitoque, e pode ser observado na Figura~[\ref{ccv}]. Ele lida com o acompanhamento dos \textit{blobs} de luz infravermelha, enviando mensagens para o \textit{Deskworld}, tais como o encostar do dedo, o deslocamento do dedo e o retirar do dedo. Interage com a maioria dos dispositivos de captura de vídeo, sendo muito útil para um projeto de software que utilize uma mesa multitoque.  Atualmente, possui suporte para plataformas \textit{Windows} e \textit{Linux}, 32 ou 64 \textit{bits}, e \textit{MacOS}.

Seu funcionamento consiste na aplicação de filtros configuráveis, como os mostrados na Figura~[\ref{filtros}]. Em seu arquivo de configuração, \textit{config.xml}, pode-se modificar os dados da câmera, tais como resolução e frames por segundo, e o \textit{CCV} irá automaticamente ajustar a câmera selecionada para os dados mais próximos suportados. A execução do \textit{CCV} funciona de acordo com o paradigma cliente-servidor, onde o mesmo atua como servidor e a aplicação como cliente. Esta comunicação cliente-servidor é feita utilizando o protocolo TUIO~[\citenum{TUIO}] \textit{(Tangible User Interface System)}, utilizando pontos normais x e y enviados via \textit{TCP}, ou em pacotes especiais para aplicativos \textit{Flash}, permitindo uma arquitetura distribuída, onde o aplicativo é executado separadamente da aplicação de processamento de imagens.

\section{Arquitetura e Detalhes de Implementação}
\label{cap5.3}

A evolução da tecnologia dos hardwares para computadores pessoais proporcionou grande desenvolvimento à indústria de jogos eletrônicos, levando-a a aprimorar seu produto ao longo do tempo. Este caminho foi marcado pela formação de grandes equipes e pela extensiva carga de codificação. Os jogos eletrônicos mais modernos podem ultrapassar um milhão de linhas de código de acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}]. Portanto, foi necessário organizar estes extensivos códigos a fim de obter uma melhor performace no desenvolvimento de novos jogos. Esta organização pode ser realizada por meio da adoção de uma arquitetura bem definida.

\subsection{Arquitetura do \textit{Deskworld}}
\label{cap5.3.1}

Apesar de não se encaixar na definição de jogo eletrônico, o \textit{Deskworld} possui muitas características semelhantes, pois é um \textit{software} interativo, onde o usuário se relaciona com objetos em um mundo virtual. Dessa maneira, este \textit{software} foi desenvolvido a partir da utilização de um padrão de desenvolvimento voltado a jogos. Para este \textit{software} foi escolhida uma arquitetura modular orientada à objetos. A próxima sessão expõe as vantagens desta arquitetura, explicando os motivos que resultaram nesta escolha.

\subsubsection{Vantagens da abordagem orientada à objetos}
\label{cap5.3.1.1}

De acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}] a maioria dos jogos se desenvolvem em torno de objetos ou entidades em um mundo virtual, onde o usuário deve realizar ações com estes objetos. Antes da existência do paradigma da orientação à objetos, os jogos eram desenvolvidos com programação procedural e assim, a ênfase da programação baseava-se no código propriamente dito. Isto porque o jogo era observado, conceitualmente, como uma sequência de código com execução de procedimentos e funções. Na programação orientada à objetos, a perspectiva é outra, pois a ênfase ocorre no conceito de objeto que é uma coleção de informações conjuntas a uma série de operações para processar estes dados. Portanto, utilizando orientação à objetos conseguimos obter \textit{softwares} que se adequam ao formato dos jogos, pois as entidades desses jogos podem ser expressas pelas classes, os objetos por instâncias da classe e ações entre eles, pelos métodos.

Outra vantagem encontrada nesta abordagem é a herança de classes, que permite a reutilização de código em múltiplas classes que possuam parentesco. Com herança, é possível estender características das superclasses para as subclasses. No \textit{Deskworld}, utilizou-se herança para, principalmente, padronizar e reutilizar parte do código dos \textit{Game Objects}. Também importante, o suporte ao polimorfismo é crucial no desenvolvimento de jogos já que permiter a realização de \textit{update} e \textit{render} de diversos componentes do \textit{software} sem precisar separá-los em chamadas de execuções diferentes, pois todos serão reconhecidos pelo seu tipo e terão seus respectivos métodos executados corretamente.

A arquitetura do programa foi modularizada para especificar claramente os  seus subsistemas, facilitando a manutenção e o entendimento do código. No diagrama~[\ref{diag-deskworld}] é observada a composição de módulos do \textit{Deskworld} e suas principais classes. A decomposição em módulos facilita a visualização da implementação, já que o \textit{Software} possui subsistemas bem claramente definidos como os de áudio, vídeo, \textit{engine} e de \textit{input}.

\subsection{Detalhes de implementação}
\label{cap5.3.2}

Esta seção apresenta a lógica utilizada na implementação do \textit{software}. Primeiramente, é exposto uma visão geral do funcionamento do sistema. Em seguida, os subsistemas são detalhados e seus papéis traçados.

\subsubsection{Visão Geral do \textit{Software}}
\label{cap5.3.2.1}

Como observado no diagrama da Figura~[\ref{diag-deskworld}], existe um \textit{Game Manager} responsável pelo gerenciamento da execução do programa. Suas principais ações são inicializar os subsistemas de áudio, vídeo, carregar o cenário e inicializar a \textit{Engine} física do \textit{Deskworld}. A classe áudio é responsável por carregar arquivos de áudio, bem como manipulá-los, podendo tocar, parar ou resumir um arquivo carregado. A \textit{Graphics} implementa soluções para renderizar os objetos na tela e gerenciar a memória de vídeo. O \textit{InputManager} trata as mensagens de entrada recebidas, explorados na seção~[\ref{cap5.2.2.2}], e gera eventos relativos aos toques. A \textit{Engine} tem como objetivo criar, alterar e posicionar objetos no mundo, além de se comunicar de posse destas informações  com a \textit{Box2D}. A classe \textit{LevelState} concentra o maior fluxo de informações, pois todas as instâncias de classe de objetos do mundo são criada nela. Os métodos de \textit{Update}, muito importante em simulações físicas, e \textit{Render} têm suas chamadas realizadas pelo \textit{LevelState}. O \textit{Game Object} armazena informações sobre os objetos como sua dimensão, posição e estado.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.35]{DeskworldDiagram.png}
	\caption{Diagrama de classes do \textit{Deskworld}}
	\label{diag-deskworld}
	\end{center}
\end{figure}

\subsubsection{Subsistemas de Áudio e Vídeo}
\label{cap5.3.2.2}

O subsistema de áudio possui atributos para identificar o nome do arquivo de áudio, o tipo do arquivo e um ponteiro para seu endereçamento na memória. Seu construtor carrega o arquivo de áudio para memória e retorna esse endereço ao ponteiro da classe. Utiliza-se esta classe para tocar e pausar a música de fundo. 

A classe \textit{Graphics} gerencia a memória de vídeo com a \textit{OpenGL}, e a utiliza para desenhar formas geométricas na tela. A classe \textit{ImageLoader} carrega imagens e texturas e renderiza-as. As texturas presentes no \textit{Software} são o fundo, menu e seus componentes.

\textbf{\textit{Singleton}}

A classe \textit{Graphics} é um \textit{Singleton}, isto é, possui, obrigatoriamente, apenas uma instância durante todo o programa. \textit{Singleton} é um \textit{Design Pattern} muito utilizado em situações que necessitam de grande controle sobre uma classe para que seja instaciada somente uma vez. Esta técnica consiste em declarar um construtor privado que será executado uma única vez. Constrói-se um método que retorna a instância única por meio de um ponteiro estático. Caso seja a primeira vez que é chamado, a classe é instanciada, caso contrário, retorna a instância já existente. Além desta, o \textit{InputManager} e a \textit{Engine} são singletons. Isto acontece porque todas essas classes só devem possuir somente uma instância, pois não se deseja várias instâncias controlando a saída de vídeo, a entrada de dados ou a simulação de objetos.

\subsubsection{Subsistema de \textit{Input}}
\label{cap5.3.2.3}

Neste subsistema, para dar suporte ao protocolo TUIO, tem-se a classe \textit{InputManager}, derivada da classe \textit{TuioListener}, que implementa métodos para escutar mensagens relativas à detecção de toques, gerando eventos. Estes eventos podem adicionar e remover toques ou atualizar suas posições. Também suporta a detecção de eventos de input via mouse ou teclado. O método principal da classe é o \textit{Update}, onde são percorridos todos os eventos enviados durante um \textit{Game Loop}, cada um sendo analisado e seus dados separados para utilização das outras classes. Por exemplo, caso seja adicionado um toque, o número identificador deste toque é salvo, permitindo que outra classe possa utilizá-lo por meio do método \textit{IsTouching}, de modo a descobrir se o toque com o identificador desejado está tocando ou não a superfície.

\subsubsection{Subsistema da \textit{Engine}}
\label{cap5.3.2.4}

A \textit{Engine} é composta pela classe \textit{Engine}, além do pacotes de classes da biblioteca \textit{Box2D}. Por intermédio destas classes, ocorre a criação dos objetos no mundo virtual. A simulação de gravidade, da força de atrito, e das forças de ação e reação, são calculadas pela \textit{Engine}. Um importante recurso para uma boa simulação é a detecção de colisão, tratada por esse subsistema. Também são realizadas operações de destruição de objetos, além da localização dos objetos ser atualizada e repassada aos outros módulos pela \textit{Engine}.

\subsubsection{Subsistema de gerência de objetos}
\label{cap5.3.2.5}

A classe \textit{LevelState} é responsável pelo único estado do \textit{software}. Estar no estado de \textit{LevelState} significa que o \textit{software} está em execução e o usuário pode interagir como desejar, criando objetos ou mudando propriedades. Nesta classe, todas as imagens que aparecem dentro do jogo são carregadas e renderizadas na tela. Seu método de \textit{Update}, chamado uma vez pelo \textit{Game Loop}, verifica todos os toques existentes ou removidos e decide o que cada um irá fazer, como por exemplo, criar um objeto novo, arrastar um objeto existente, abrir o menu ou alterar as opções. Seu outro método, \textit{Render}, é responsável por montar a tela do jogo, renderizando na tela todas as imagens em sua sequência, deixando-as prontas para serem mostradas na tela, assim que tudo estiver em posição.

A \textit{GameObject} é uma superclasse que agrega subclasses referentes a todos objetos presentes \textit{software}. Estas classes representam os objetos desenhados no programa que podem ser polígonos, círculos ou terem forma livre. Além disso, objetos podem ser motores e juntas. O próprio mundo é um objeto, pois podem existir vários mundos, e as próprias barreiras usadas para dividir entre submundos também são consideradas objetos. Todos objetos possuem vértices que indicam suas posições e suas áreas. Todos os \textit{GameObject}s possuem métodos de \textit{Update} e \textit{Render}.