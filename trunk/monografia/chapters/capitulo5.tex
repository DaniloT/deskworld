\chapter{\textit{Software Deskworld}}
\label{cap5}

Neste capítulo, é apresentado o \textit{Design} do \textit{Software Deskworld} bem como seus detalhes de implementação, sua arquitetura e a estrutura utilizada para implementar o simulador.

\section{\textit{Design} do \textit{Deskworld}}
\label{cap5.1}

Nesta seção, apresenta-se o \textit{Design} do \textit{Software}, isto é, o projeto da aplicação, com suas características em uma visão computacional de alto nível, ou seja, a nível de usuário.

\subsection{Requisitos de interface}
\label{cap5.1.1}

\begin{itemize}
	\item Sua mecânica deve permitir a participação de diversos jogadores simultaneamente.
	\item Suportar e processar toques simultaneamente.
	\item Capacidade de aproximar formas.
\end{itemize}

\subsection{Conceito}
\label{cap5.1.2}
O simulador de física \textit{Deskworld} tem como principal proposta deixar a encargo da criatividade do(s) usuário(s) a construções de cenários, objetos e seus objetivos no respectivo mundo. O principal objetivo é prover ferramentas aos usuários para auxiliá-los nessa construção. Assim sendo, objetos e elementos físicos são representados em um plano bidimensional e regidos pelas leis da física. É possível desenhar um objeto e associá-lo a algum tipo de elemento de acordo com suas propriedades como massa, coeficiente de atrito e elasticidade. O usuário pode aplicar uma força a este objeto como a gravidade, fixá-lo no plano, entre outras opções. Ainda, para poder mudar propriedades do mundo em que se encontra e poder utilizar o \textit{software} sem ser interrompido, um usuário pode dividir o mundo, criando um novo sub-mundo para seu uso separado. Os usuários têm a maior liberdade possível para criar diferentes mundos, fazer desenhos ou a simulação de objetos.

\subsection{Regras e Objetos}
\label{cap5.1.3}
Basicamente, pode-se criar qualquer tipo de objeto 2D com ou sem auxílio das ferramentas fornecidas. A construção funciona como desenhar virtualmente, sendo o dedo o lápis e a superfície da mesa o papel.

Cada objeto pode ter as seguintes características:
\begin{itemize}
	\item Densidade
	\item Coeficiente de atrito
	\item Coeficiente de restituição de força
	\item Força normal
	\item Massa
	\item Volume
	\item Velocidade
\end{itemize}

Dessas, densidade, coeficiente de atrito, coeficiente de restituição de força e massa podem ser alterados pelo usuário a qualquer momento.

Além dessas propriedades, os objetos podem interagir entre si por meio de juntas, colisões ou com motores adicionados aos objetos. Também é possível a separação de mundos com gravidades diferentes e cores de pincél diferentes dos outros mundos.

Neste simulador não existe uma regra pré-definida, ela pode ser definida pontualmente por um usuário ao criar um cenário e objetos.

\subsection{Interface}
\label{cap5.1.4}
A interface utilizada para testes é a mesa descrita no capítulo~\ref{cap4}. Porém, o jogo é portável para qualquer interface multi-toque que suporte o protocolo \textit{TUIO}.

\section{Ferramentas de suporte do simulador}
\label{cap5.2}

Nesta seção, serão descritos as ferramentas de suporte utilizadas na construção do simulador.

\subsection{\textit{Game Engine}}
\label{cap5.2.1}

A \textit{engine} utilizada neste \textit{software} foi a \textit{Box2D}. Seu manual pode ser encontrado em~[\citenum{Box2Dmanual}]. A principal funcionalidade da \textit{Box2D} neste \textit{software} foi auxiliar na criação dos objetos e no tratamento de eventos relacionados a simulação das leis da física. Estes eventos estão apresentados abaixo.

\begin{itemize}
	\item Gravidade
	\item Colisão
	\item Força de ação e reação
	\item Força de atrito
	\item Força de fricção
\end{itemize}

Além dessas funcionalidades, a \textit{Box2D} é responsável pela gerência de memória, junção de objetos e/ou fixação deles.

\subsection{\textit{Bibliotecas de apoio}}
\label{cap5.2.2}

Para facilitar a implementação do \textit{software} foram utilizadas diversas bibliotecas. Uma das bibliotecas padrão do C++, a \textit{STL} \textit{(Standart Template Library)}, possui algumas estruturas complexas de dados já implementadas, sendo amplamente utilizada neste simulador. Para a parte gráfica do jogo foi utilizada a biblioteca \textit{SDL} \textit{(Simple Direct Layer)} conjuntamente com a \textit{OpenGL} (\textit{Open Graphics Library}). Com relação ao áudio, utilizou-se a \textit{SDL\_mixer}. Para tratamento de \textit{input} foi utilizada a \textit{Touchlib}.

\subsubsection{\textit{SDL} e \textit{OpenGL}}
\label{cap5.2.2.1}

Por oferecer uma boa abstração de \textit{hardware}, ser bem difundida no mercado de jogos e possuir ampla documentação, utilizou-se a \textit{SDL} para disponibilizar o acesso ao ambiente. Conjuntamente com a \textit{SDL}, na parte gráfica, foi utilizado a \textit{OpenGL} (\textit{Open Graphics Library}) que realiza a renderização das imagens.

A \textit{SDL\_mixer} é utilizada para permitir a reprodução de diversas faixas de audio simultaneamente.

\subsubsection{Protocolo \textit{TUIO}}
\label{cap5.2.2.2}

Comunicação entre o usuário da mesa com o aplicativo é realizada de acordo com o protocolo \textit{TUIO}~[\citenum{TUIO}] (\textit{Tangible User Interface System}). Este protocolo é especificado para atender as necessidades da comunicação das interfaces tangíveis. Interfaces tangíveis são interfaces sensíveis ao toque, capazes de serem controladas por movimentos corporais e gestos. A implementação é simples e visa melhorar a performance na comunicação. Para isso, ele opera sobre a camada \textit{UDP}(\textit{User Datagram Protocol}) de transporte utilizando três tipos de mensagens: \textit{set}, \textit{alive} e \textit{fseq}. Mensagens \textit{set} são utilizadas para informar o estado de um objeto. Mensagens \textit{alive} indicam o conjunto de objetos presentes na interface através de uma identificação única atribuída a cada novo elemento reconhecido. Mensagens \textit{fseq} são transmitidas antes da etapa de atualização de cada quadro para marcá-lo unicamente, associando-o a cada mensagem \textit{set} e \textit{alive} dele. Resumindo o funcionamento do protocolo:

\begin{itemize}
	\item Parâmetros do objeto são enviados após mudança de estado através da mensagem \textit{set}
	\item Objetos removidos da interface são comunicados através de mensagens \textit{alive}
	\item Cliente deduz a lista de objetos adicionados e removido por meio das mensagens \textit{set} e \textit{alive}
	\item Mensagens \textit{fseq} associam um ID a um conjunto de mensagens \textit{set} e \textit{alive} do quadro
\end{itemize}

Apesar da camada UDP de transporte não oferecer garantia de entrega dos dados, o TUIO implementa redundância de informação para se precaver contra a perda de dados na transmissão. Além disso, o estado de um objeto, mesmo inalterado, é enviado periodicamente em uma mensagem \textit{set}. Portanto, o protocolo é ideal para ser utilizado em aplicativos controlados por interfaces multitoques otimizando a interação e confiabilidade da comunicação.

\textbf{\large{Parâmetros das mensagens TUIO}}

\begin{table}[htbp]
  \centering
  	\caption{Parâmetros de mensagens TUIO em superfícies interativas 2D}
    \begin{tabular}{|l|l|l|} %rrr}
    \textbf{Parametros} & \textbf{Significado dos parametros} & \textbf{Tipo} \\
    s     & sessionID (ID temporário do objeto) & int32 \\
    x, y  & posição & float32 \\
    X, Y  & vetor de movimento (velocidade de movimento e direção) & float32 \\
    m     & aceleração de movimento & float32 \\
    w, h  & largura e altura do \textit{blob} & float32 \\
    \end{tabular}%
  \label{tab:tabela1_param_TUIO}%
\end{table}%

\subsubsection{\textit{Community Core Vision}}
\label{cap5.2.3}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.4]{ccv.jpg}
	\caption{Aplicativo de captura de toques \textit{Community Core Vision}~[\citenum{ccv}]}
	\label{ccv}
	\end{center}
\end{figure}

O \textit{CCV} (\textit{Community Core Vision})~[\citenum{ccv}] é um aplicativo para auxiliar o processamento de imagens capturadas pela câmera em interações com superfícies multi-toque, e pode ser observado na Figura~[\ref{ccv}]. Ela lida com o acompanhamento de \textit{blobs} de luz infravermelha, e envia para seus programas esses eventos multi-toques, como o encostar do dedo, deslocamento do dedo e o retirar do dedo. Interage com a maioria dos tipos de dispositivos de captura de vídeo sendo muito útil para um projeto de \textit{software} para mesa multi-toque. Atualmente, possui suporte para plataformas \textit{Windows} e \textit{Linux}, 32 ou 64 \textit{bits}, e \textit{MacOS}.

Seu funcionamento consiste na aplicação de filtros de forma customizável como os mostrados na Figura~[\ref{filtros}]. Em seu arquivo de configuração, \textit{config.xml}, pode-se modificar dados da câmera, como resolução e frames por segundo, e a \textit{CCV} irá automaticamente ajustar a câmera selecionada para os dados mais próximos suportados. A execução da \textit{CCV} funciona de acordo com o paradigma cliente-servidor, sendo a mesma atuando como servidor e a aplicação como cliente. Esta comunicação cliente-servidor é feita utilizando o protocolo TUIO~[\citenum{TUIO}] \textit{(Tangible User Interface System)}, utilizando pontos normais x e y enviados via \textit{TCP}, ou em pacotes especiais para aplicativos \textit{Flash}, permitindo uma arquitetura distribuída, onde o aplicativo é executado separadamente da aplicação de processamento de imagens.

\section{Arquitetura e Detalhes de Implementação}
\label{cap5.3}

A evolução da tecnologia dos hardwares dos computadores pessoais proporcionou grande desenvolvimento à indústria de jogos eletrônicos levando-a a aprimorar seu produto ao longo do tempo. Este caminho foi marcado por grandes equipes e pela extensiva codificação. Os jogos eletrônicos mais modernos podem ultrapassar um milhão de linhas de código de acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}]. Portanto, foi necessário organizar estes extensivos códigos a fim de obter melhor performace no desenvolvimento de novos jogos. Esta organização pode ser realizada por meio da adoção de uma arquitetura bem definida.

\subsection{Arquitetura do \textit{Deskworld}}
\label{cap5.3.1}

Apesar de não se encaixar na definição de jogo eletrônico, \textit{Deskworld} possui muitas características semelhantes, pois é um \textit{software} interativo onde o usuário se relaciona com objetos em um mundo virtual. Portanto, este \textit{software} foi desenvolvido utilizando um padrão de desenvolvimento voltado a jogos. Para este \textit{software} foi escolhida uma arquitetura modular orientada à objetos. A próxima sessão expõe as vantagens desta arquitetura, explicando os motivos que resultaram nesta escolha.

\subsubsection{Vantagens da abordagem orientada à objetos}
\label{cap5.3.1.1}

De acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}] a maioria dos jogos se desenvolvem em torno de objetos ou entidades em um mundo virtual, onde o usuário deve realizar ações com estes objetos. Antes de existir o paradigma de orientação à objetos, os jogos eram desenvolvidos com programação procedural e assim, a ênfase da programação baseava-se no código propriamente dito. Isto porque o jogo era observado, conceitualmente, como uma sequência de código com execução de procedimentos e funções. Na programação orientada à objetos a perspectiva é outra, pois a ênfase ocorre no conceito de objeto que é uma coleção de informações conjuntas a uma série de operações para processar estes dados. Portanto, utilizando orientação à objetos conseguimos obter \textit{Softwares} que se adequam ao formato dos jogos, pois as entidades dos jogos podem ser expressas pelas classes, os objetos por instâncias da classe e ações entre eles geram métodos.

Outra vantagem encontrada nesta abordagem é a herança de classes que permite a reutilização de código em múltiplas classes que possuam parentesco. Com herança é possível extender características das superclasses para as subclasses. No \textit{Deskworld} utilizamos herança para, principalmente, padronizar e reutilizar parte do código dos \textit{Game Objects}. Também importante, o suporte a polimorfismo é crucial no desenvolvimento de jogos já que podemos dar \textit{update} e renderizar diversos componentes do \textit{Software} sem precisar separar em chamadas de execuções diferentes, pois todos serão reconhecidos pelo seu tipo e terão seus respectivos métodos executados corretamente.

A arquitetura do programa foi modularizada para especificar claramente os subsistemas de jogo, facilitando a manutenção e o entendimento do código. No diagrama~[\ref{(** DIAGRAMA **)}] é observado a composição de módulos e suas classes principais do \textit{Deskworld}. A decomposição em módulos facilita a visualização da implementação, já que o \textit{Software} possui subsistemas bem claramente definidos como os de áudio, vídeo, \textit{engine} e de \textit{input}.

\subsection{Detalhes de implementação}
\label{cap5.3.2}

Esta seção esclare a lógica utilizada na implementação do \textit{Software}. Primeiramente, é exposto uma visão geral do funcionamento do sistema. Em seguida, os subsistemas são detalhados e seus papéis traçados.

\subsubsection{Visão Geral do \textit{Software}}
\label{cap5.3.2.1}

Como observado na Figura~[\ref{(** DIAGRAMA **)}], existe um \textit{Game Manager} responsável pelo gerenciamento da execução do programa. Suas principais ações são inicializar os subsistemas de áudio, vídeo, carregar o cenário e inicializar a \textit{Engine} física do \textit{Software}. A classe áudio é responsável por carregar arquivos de áudio bem como manipulá-los, podendo tocar, parar ou resumir um arquivo carregado. A \textit{Graphics} implementa soluções para renderizar os objetos na tela e gerencia a memória de vídeo. \textit{InputManager} trata as mensagens de entrada recebidas, explorados na seção~[\ref{cap5.2.2.2}], e gera eventos relativo aos toques. A \textit{Engine} tem como objetivo criar e alterar, posicionar objetos no mundo, além de se comunicar com estas informações a \textit{Box2D}. A classe \textit{LevelState} é onde se concentra o maior fluxo de informações, pois todas as instacias de classe de objetos do mundo são criada nela, os métodos de \textit{Update}, muito importante em simulações físicas, e \textit{Render} tem suas chamadas realizadas pelo \textit{LevelState}. \textit{Game Object} guarda a informação sobre os objetos como sua dimensão, posição e estado.

\subsubsection{Subsistemas de Áudio e Vídeo}
\label{cap5.3.2.2}

Possui atributos para identificar o nome do arquivo de áudio, tipo de arquivo e um ponteiro para seu endeçamento na memória. Seu construtor carrega o arquivo de áudio para memória e retorna esse endereço ao ponteiro da classe. Utiliza-se esta classe para tocar e pausar a música de fundo. 

Quanto a classe \textit{Graphics}, gerencia a memória de vídeo com a \textit{OpenGL} e a utilizara para desenhar polígonos na tela e círculos. A classe \textit{ImageLoader} carrega imagens e texturas e renderiza-as. As texturas presentes no \textit{Software} são o fundo, menu e seus componentes.

\Large\textbf{\textit{Singleton}} 

A classe \textit{Graphics} é um \textit{Singleton}, isto é, possui, obrigatoriamente, apenas uma instância durante todo o programa. \textit{Singleton} é um \textit{Design Pattern} muito utilizado em situações que necessitam de grande controle sobre uma classe para que seja instaciada somente uma vez. Esta técnica consiste em declarar um construtor privado que será executado uma única vez. Constrói-se um método que retorna a instância única através de um ponteiro estático. Caso seja a primeira vez que é chamado, a classe é instanciada, caso contrário, retorna a instância já existente. Além desta, o \textit{InputManager} e a \textit{Engine} são singletons. Isto acontece porque todas essas classes só devem possuir somente uma instância, pois não queremos várias instâncias controlando a saída de vídeo, a entrada de dados ou a simulação de objetos.

\subsubsection{Subsistema de \textit{Input}}
\label{cap5.3.2.3}

Neste subsistema, para dar suporte ao protocolo TUIO, tem-se a classe \textit{InputManager}, derivada da classe \textit{TuioListener}, que implementa métodos para escutar mensagens relativas à detecção de toques, gerando eventos. Estes eventos podem ser para adicionar toques, remover toques ou atualizar posições de toques, ou ainda para detecção de eventos de input via mouse ou teclado. O método principal da classe é o \textit{Update}, onde são percorridos todos os eventos enviados durante um \textit{Game Loop}, cada um sendo analisado e seus dados separados para utilização das outras classes. Por exemplo, caso seja adicionado um toque, é salvo o número identificador deste toque e o fato de que está tocando a superfície, para que outra classe possa utilizar o método \textit{IsTouching} para descobrir se o toque com o identificador desejado está tocando ou não a superfície.

\subsubsection{Subsistemas de \textit{LevelState}}
\label{cap5.3.2.4}

A classe \textit{LevelState} é responsável pelo único estado do \textit{software}. Estar no estado de \textit{LevelState} significa que o \textit{software} está rodando e o usuário pode interagir como desejar, criando objetos ou mudando propriedades. Nesta classe, todas as imagens que aparecem dentro do jogo são carregadas e renderizadas na tela. Seu método de \textit{Update}, chamado uma vez por \textit{Game Loop}, verifica todos os toques existentes ou removidos e decide o que cada um irá fazer, criar um objeto novo, arrastar um objeto existente, abrir o menu ou mudar opções. Seu outro método, \textit{Render}, é responsável por montar a tela do jogo, renderizando na tela todas as imagens na sequência delas, deixando pronto para se mostrar na tela uma vez que tudo estiver em posição.