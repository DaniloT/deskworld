\chapter{Implementação do \textit{Software Deskworld}}
\label{cap5}

Neste capítulo, é apresentado o \textit{Design} do \textit{Software Deskworld} bem como seus detalhes de implementação, sua arquitetura e a estrutura utilizada para implementar o simulador.

\section{\textit{Design} do \textit{Deskworld}}
\label{cap5.1}

Nesta seção, apresenta-se o \textit{Design} do \textit{Software}, isto é, o projeto da aplicação, com suas características em uma visão computacional de alto nível, ou seja, a nível de usuário.

\section{Requisitos de interface}
\label{cap5.1.1}

\begin{itemize}
	\item Sua mecânica deve permitir a participação de diversos jogadores simultaneamente.
	\item Suportar e processar multi-toque simultaneamente.
	\item Capacidade de captar gestos.
\end{itemize}

\subsection{Conceito}
\label{cap5.1.2}
O simulador de física \textit{Deskworld} tem como principal proposta deixar a encargo da criatividade do(s) jogador(es) a construções de cenários, objetos e seus objetivos no respectivo mundo. O principal objetivo é prover ferramentas aos usuários para auxiliá-los na construção. Assim sendo, objetos e elementos físicos são representados em um plano bidimensional e regido pelas leis da física. É possível desenhar um objeto e associá-lo a algum tipo de elemento de acordo com suas propriedades como densidade, massa, coeficiente de atrito e elasticidade. O usuário pode aplicar uma força a este objeto como a gravidade, fixá-lo no plano, entre outras opções. Os usuários têm a maior liberadade possível para criar diferentes jogos, fazer desenhos ou a simulação de objetos.

\subsection{Regras e Objetos}
\label{cap5.1.3}
Basicamente, pode-se criar qualquer tipo de objeto bidimensional com ou sem auxílio das ferramentas fornecidas. A construção funciona como desenhar virtualmente, sendo o dedo o lápis e a superfície da mesa o papel.

Cada objeto pode ter as seguintes características:
\begin{itemize}
	\item Densidade
	\item Coeficiente de Atritro
	\item Força Normal
	\item Massa
	\item Volume
	\item Velocidade
\end{itemize}

%Além dessas propriedades, os objetos podem interagir entre si por meio de juntas, colisões ou como motores de outro objeto.

Neste simulador não existe uma regra pré-definida, ela pode ser definida pontualmente por um usuário ao criar um cenário e objetos.

\subsection{Interface}
\label{cap5.1.4}
Interface utilizada para testes é a mesa descrita no capítulo~\ref{cap4}. Porém, o jogo é portável para qualquer interface multi-toque.

\section{Estrutura de implementação do simulador}
\label{cap5.2}

Nesta seção, será descrito as ferramentas de suporte utilizadas na construção do simulador.

\subsection{\textit{Game Engine}}
\label{cap5.2.1}

A \textit{engine} utilizada neste jogo foi a \textit{Box2D}.Seu manual pode ser encontrado em~[\citenum{Box2Dmanual}]. A principal funcionalidade da \textit{Box2D} neste jogo foi auxiliar na criação dos objetos e no tratamento de eventos relacionados a simulação das leis da física. Estes eventos estão apresentados abaixo:

\begin{itemize}
	\item Gravidade
	\item Colisão
	\item Força de ação e reação
	\item Força de atrito
	\item Força de fricção
\end{itemize}

Além dessas funcionalidades, a \textit{Box2D} é responsável pela gerência de memória, junção de objetos e/ou fixação deles.

\subsection{\textit{Bibliotecas de apoio}}
\label{cap5.2.2}

Para facilitar a implementação de foram utilizadas diversas bibliotecas. Uma das bibliotecas padrão do C++ a STL \textit{(Standart Template Library)} possui algumas estruturas complexas de dados já implementadas, sendo amplamente utilizada neste simulador. Para a parte gráfica do jogo foi utilizada a biblioteca SDL \textit{(Simple Direct Layer)} conjuntamente com a \textit{OpenGL} (\textit{Open Graphics Library}). Com relação ao áudio, utilizou-se a SDL\_mixer. Para tratamento de \textit{input} foi utilizada a \textit{Touchlib}.

\subsubsection{SDL e \textit{OpenGL}}
\label{cap5.2.2.1}

Por oferecer uma boa abstração de \textit{hardware}, ser bem difundida no mercado de jogos e possuir ampla documentação, utilizou-se a SDL para disponibilizar o acesso ao ambiente \textit{OpenGL}. Conjuntamente com a SDL, na parte gráfica, foi utilizado a \textit{OpenGL} (\textit{Open Graphics Library}) que realiza a renderização das imagens.

A SDL\_mixer é utilizada para permitir a reprodução de diversas faixas de audio simultaneamente.

\subsubsection{Protocolo \textit{TUIO}}
\label{cap5.2.2.2}

Comunicação entre o usuário da mesa com o aplicativo é realizada de acordo com o protocolo \textit{TUIO}~[\citenum{TUIO}] (\textit{Tangible User Interface System}). Este protocolo especificado para atender as necessidades da comunicação das interfaces tangíveis. Interfaces tangíveis são interfaces sensíveis a toque, capazes de serem controladas por movimentos corporais e gestos. A implementação é simples e visa melhorar a performace na comunicação. Para isso, ele opera sobre a camada UDP(\textit{User Datagram Protocol}) de transporte utilizando três tipos de mensagens: \textit{set}, \textit{alive} e \textit{fseq}. Mensagens \textit{set} são utilizadas para informar o estado de um objeto. Mensagens \textit{alive} indicam o conjunto de objetos presentes na interface através de uma identificação única atribuída a cada novo elemento reconhecido. Mensagens \textit{fseq} são transmitidas antes da etapa de atualização de cada quadro para marcar-lo unicamente, associando-o a cada mensagem \textit{set} e \textit{alive} dele. Resumindo o funcionamento do protocolo:

\begin{itemize}
	\item Parâmetros do objeto são enviados após mudança de estado através da mensagem \textit{set}
	\item Objetos removidos da interface são comunicados através de mensagens \textit{alive}
	\item Cliente deduz a lista de objetos adicionados e removido por meio das mensagens \textit{set} e \textit{alive}
	\item Mensagens \textit{fseq} associam um ID a um conjunto de mensagens \textit{set} e \textit{alive} do quadro
\end{itemize}

Apesar da camada UDP de transporte não oferecer garantia de entrega dos dados, o TUIO implementa redundância de informação para se precaver contra a perda de dados na transmissão. Além disso, o estado de um objeto, mesmo inalterado, é enviado periodicamente em uma mensagem \textit{set}. Portanto, o protocolo é ideal para ser utilizado em aplicativos controlados interfaces multitoques otimizando a iteração e confiabilidade da comunicação.

\textbf{\large{Parâmetros das mensagens TUIO}}

\begin{table}[htbp]
  \centering
  	\caption{Parâmetros de mensagens TUIO em superfícies interativas 2D}
    \begin{tabular}{|l|l|l|} %rrr}
    \textbf{Parametros} & \textbf{Significado dos parametros} & \textbf{Tipo} \\
    s     & sessionID (ID temporário do objeto) & int32 \\
    x, y  & posição & float32 \\
    X, Y  & vetor de movimento (velocidade de movimento e direção) & float32 \\
    m     & aceleração de movimento & float32 \\
    w, h  & largura e altura do \textit{blob} & float32 \\
    \end{tabular}%
  \label{tab:tabela1_param_TUIO}%
\end{table}%

\subsubsection{\textit{Touchlib}}
\label{cap5.2.3}

\textit{Touchlib}~[\citenum{Touchlib}] é uma biblioteca para auxiliar o processamento de imagens capturadas pela webcam em iterações com superfícies multitoque. Ela lida com o acompanhamento de \textit{blobs} de luz infravermelha, e envia para seus programas esses eventos multitoques, como o encostar do dedo, deslocamento do dedo e o retirar do dedo. Inclui um aplicativo de configuração, algumas demos para exemplificar seu uso. Interage com a maioria dos tipos de webcams e os dispositivos de captura de vídeo sendo muito útil para um projeto de \textit{software} para mesa multitoque. Em contrapartida só tem suporte para para sistema operacional \textit{Windows}.

Seu funcionamento consiste na aplicação de filtros de forma customizável como os mostrados nesta figura~[\ref{filtros}]. A execução destes filtros são realizadas pela \textit{Touchlib} com o uso da \textit{OpenCV (Open Source Computer Vision Library)}, uma biblioteca para o desenvolvimento de aplicativos de processamento de imagens. A execução da \textit{Touchlib} funciona de acordo com o paradigma cliente-servidor, sendo a mesma atuando como servidor e a aplicação como cliente. Esta comunicação cliente-servidor é feita utilizando o protocolo TUIO~[\citenum{TUIO}] \textit{(Tangible User Interface System)}, permitindo uma arquitetura distribuída, onde o aplicativo é executado separadamente da aplicação do processamento de imagens.

\section{Arquitetura e Detalhes de Implementação}
\label{cap6}

\subsection{Arquitetura do jogo}
\label{cap6.1}

A evolução da tecnologia dos hardwares dos computadores pessoais proporcionou grande desenvolvimento à indústria de jogos eletrônicos levando-a a aprimorar seu produto ao longo do tempo. Este caminho foi marcado por grandes equipes e pela extensiva codificação. Os jogos eletrônicos mais modernos podem ultrapassar um milhão de linhas de código de acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}]. Portanto, foi necessário organizar estes extensivos códigos a fim de obter melhor performace no desenvolvimento de novos jogos. Esta organização pode ser realizada por meio da adoção de uma arquitetura bem definida.

Para este jogo escolhemos uma arquitetura de desenvolvimento baseada em um sistema de componentes.

\subsubsection{Sistema de Componentes}
\label{cap6.1.1}

Um sistema de componentes é caracterizado pela sua estrutura não-hierárquica. O jogo que se baseia em componentes terá somente uma classe pai que representará todas as entidades do jogo, enquanto quaisquer outras classes serão irmãs entre si, pois todas serão filhas da entidade do jogo. Cada classe filha da entidade é um componente, ou seja, o entidade do jogo é formada por uma composição de componentes.

É observado a independência de cada componente, onde podemos, por exemplo, ter a liberdade de transformar um elemento de uma classe jogador em veículo. Entretanto, mesmo com a mudança podemos manter a coerência lógica do jogo, pois estas classes terão a mesma estrutura que forma a entidade do jogo, como audio, corpo físico e aparência.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.8]{componente.png}
	\caption{Exemplo de uso de componentes em entidades de jogo~[\citenum{pedrosaulo}]}
	\label{componente}
	\end{center}
\end{figure}

\subsubsection{Vantagens em relação ao sistema hierárquico}
\label{cap6.1.2}

Um sistema baseado em componentes é uma alternativa ao forte acomplamento provocado pela hierarquia de classes. Em linguagens orientadas à objeto a hierarquia de classes pode ser de grande ajuda como pode dificultar a codificação do software. Isto porque, em sistemas onde temos tipos de objetos pré-definidos, assim como as relações entre eles, a hierarquia pode ser de grande ajuda. Isto acontece pelo fato da fácil representação do jogo como um hierarquia. Por exemplo, em jogos de esporte, geralmente, temos características fortemente consolidadas. Um jogador de basquete, dificilmente, se transformará em uma bola. A forte acoplação entre as classes favorece a implementação de uma arquitetura hierarquizada.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.65]{hierarquia.png}
	\caption{Exemplo de uso de hierarquia em entidades de jogo~[\citenum{pedrosaulo}]}
	\label{hierarquia}
	\end{center}
\end{figure}

No entanto, no caso do jogo \textit{DeskWorld} teremos problemas se utilizarmos este tipo de arquitetura. Isto porque, de acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}], uma arquitetura majoritariamente baseada em hierarquia de classes possui significantes limitações. Uma de suas principais é a baixa flexibilidade devido ao forte acomplamento. O fato de termos classes hierárquicas gera a dependência \textit{inter-classe}, já que, parte de suas características são herdadas de uma classe, sendo que, mudanças realizadas em características de uma classe refletiram sobre suas filhas.

Outro ponto apresentado em~[\citenum{I2GMDVP}], é que, em linguagens bem difundidas no desenvolvimento de jogos, como \textit{C++} e \textit{Java}, a estrutura modelada em hierarquia é estática, não permitindo a alteração de classes em tempo de execução. Isto pode ser um grande entrave, pois certos jogos podem realizar diversas alterações drásticas no comportamento de entidades. Podemos exemplificar esse ponto tomando um jogo em que a morte de um certo inimigo possa se transformar em um item ou dinheiro.

\subsubsection{Comunicação entre componentes}
\label{cap6.1.3}

Para aproveitar a flexibilidade provida pelo sistema de componentes, necessitamos realizar a comunicação entre componentes, visto que, será a responsável por engatilhar a transformação de uma entidade. É a mensagem que avisará ao objeto que seu comportamento irá ser alterado e associado a uma outra classe.

Esta comunicação pode ficar a cargo da entidade do jogo, onde, por exemplo, pode realizar a transferência de um som de uma classe de áudio para uma classe veículo. Num sistema simples, essa comunicação pode ser implementada por uma simples chamada de função onde ponteiros são passados referênciando suas respectivas características.

\subsection{\textit{Design Patterns}}
\label{cap6.2}

\textit{Design Patterns} são padrões de projeto de orientação a objetos que visam reconhecer padrões recorrentes de forma a aumentar a flexibilidade e permitir o reuso do código se usados de forma adequada. Isso se dá pois o seu uso aumenta a indepêndencia dos sistemas, o que também aumenta a capacidade de evolução do código em si.

Como foi descrito em~[\citenum{pedrosaulo}], para cada padrão, são estabelecidos os seguintes aspectos:
\begin{itemize}
	\item{O \textbf{nome} usado para descrever, de maneira sucinta e precisa em no máximo duas palavras, o problema, a solução e as consequências inerentes do padrão.}
	\item{O \textbf{problema} e o contexto adequados para a aplicação do padrão.}
	\item{A \textbf{solução} descreve os elementos que compõem o padrão. Cada solução inclui relacionamentos entre classes e a colaboração entre estes casos existam.}
	\item{As \textbf{consequências} de se aplicar o padrão, ou seja, os resultados e as desvantagens.}
\end{itemize}

Graças ao fato de jogos serem extremamente modulares, eles ganham um grande benefício por utilizar alguns padrões de projeto. Abaixo estão explicados os mais utilizados para este propósito.

\subsubsection{\textit{Singleton}}
\label{cap6.2.1}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=1]{singleton.png}
	\caption{Padrão \textit{Singleton}~[\citenum{pedrosaulo}]}
	\label{singleton}
	\end{center}
\end{figure}

O padrão \textit{Singleton} trata de um padrão aonde uma classe necessita necessariamente ser única durante todo o programa, mesmo ela podendo ser utilizada em várias situações.

Através desse padrão, a classe \textit{Singleton} cuida para que ela seja instanciada somente uma vez. Podemos verificar a implementação desse padrão na figura~[\ref{singleton}], onde temos uma operação de classe, 'Instance()', que retorna a única instância, e é salvo como ponteiro estático dessa classe. Caso seja a primeira vez que é chamado, a classe é instaciada, caso contrário, retorna a instância já existente. O construtor é privado para que a classe não possa ser criada por fora dela.

Em jogos, o padrão \textit{Singleton} é muito usado para controlar eventos e gerenciar mensagens, bem como controlar recursos. Em todos esses casos, apensa uma instância pode existir e ela deve permitir acesso global a ela.

\subsubsection{\textit{Observer}}
\label{cap6.2.2}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=1]{observer.png}
	\caption{Padrão \textit{Observer}~[\citenum{pedrosaulo}]}
	\label{observer}
	\end{center}
\end{figure}

O padrão \textit{Observer}, visto na figura~[\ref{observer}], define um padrão onde um objeto, chamado de \textit{subject}, mantêm uma lista de observadores e os notifica de mudanças de estados. Quando a informação é passada, os observadores consultam o \textit{subject} para sincronizar os dados. O \textit{subject} não precisa conhecer detalhes do observador.

Utilizando a classe \textit{subject}, podemos adicionar ou remover observadores O observador, no entanto, define uma interface para objetos que notificam sobre sua alteração para o subject. Essa é a única ligação entre o observador e o \textit{subject}.

Este padrão também é reconhecido na indústria de jogo. Como a arquitetura de jogos é marcada pela interação entre entidades distintas, o \textit{observer} deve ser usado. Assim as entidades se conhecem e aguardam receber atualizações de outras entidades que compõem o seu meio ambiente.

