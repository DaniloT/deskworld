\chapter{\textit{Software Deskworld}}
\label{cap5}

Neste capítulo é apresentado o projeto do \textit{Software Deskworld} (Figura~\ref{deskworldmesa}) e seus detalhes de implementação, tais como arquitetura e a estrutura empregada.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.1]{fotodeskworldmesa.JPG}
	\caption{\textit{Deskworld} sendo utilizado na mesa.}
	\label{deskworldmesa}
	\end{center}
\end{figure}

\section{\textit{Design} do \textit{Deskworld}}
\label{cap5.1}

Nesta seção, apresenta-se o projeto do \textit{Software}, isto é, o projeto de sua aplicação com as características expressas em uma visão computacional de alto nível, ou seja, a nível de usuário.

\subsection{Requisitos de interface}
\label{cap5.1.1}

De maneira simplificada, os requisitos de interface do \textit{Deskworld} podem ser expressos da seguinte forma:
\begin{itemize}
	\item sua mecânica deve permitir a participação de diversos jogadores simultaneamente;
	\item deve suportar e processar toques simultâneos;
	\item deve possuir capacidade de aproximar linhas.
\end{itemize}

\subsection{Conceito}
\label{cap5.1.2}
O simulador de física \textit{Deskworld} tem como principal proposta deixar a cargo da criatividade do(s) usuário(s) a construções de cenários, objetos e seus respectivos objetivos em seu mundo virtual. A meta principal é prover ferramentas aos usuários, auxiliando-os nessa construção. Assim, objetos e elementos físicos são representados em um plano bidimensional, regidos pelas leis da física. É possível desenhar um objeto e modificar suas propriedades tais como massa, coeficiente de atrito e elasticidade. O usuário pode aplicar uma força a este objeto como a gravidade, fixá-lo no plano, entre outras opções. Pode-se ainda, alterar as propriedades do mundo em que se encontra e, sem interrupções, dividí-lo, criando novos submundos para interagir separadamente.

\subsection{Regras e Objetos}
\label{cap5.1.3}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.6]{screen.png}
	\caption{Tela do \textit{software Deskworld}.}
	\label{jogo}
	\end{center}
\end{figure}

Basicamente, pode-se criar qualquer objeto bidimensional, com o auxílio das ferramentas fornecidas. A construção funciona similarmente ao desenho virtual, onde o dedo representa o lápis e a superfície da mesa o papel. Os objetos podem ser criados de forma livre, com o usuário desenhando-os como quiser, ou com auxílio do software, através de suas ferramentas ou utilizando a forma livre que, ao fechar uma forma, tenta aproximar os desenhos do usuário a polígonos convexos, como pode ser observado na Figura~\ref{aprox}.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.6]{aproximacao.png}
	\caption{Aproximação de formas a polígonos convexos.}
	\label{aprox}
	\end{center}
\end{figure}

Para a alteração de regras do mundo, ferramentas utilizadas ou propriedades dos objetos, o usuário possui um menu, que pode ser acessado através de dois toques subsequentes em um local disponível da tela. Os itens do menu podem ser selecionados com um único toque neles.

Cada objeto pode ter as seguintes características:
\begin{itemize}
	\item Densidade
	\item Coeficiente de atrito
	\item Coeficiente de restituição de força
	\item Força normal
	\item Massa
	\item Volume
	\item Velocidade
\end{itemize}

Dentre as características acima, a densidade, o coeficiente de atrito e o coeficiente de restituição de força podem ser alterados pelo usuário a qualquer momento, utilizando o menu de objetos, acessado da mesma maneira em que se acessa o menu tradicional, mas com o duplo clique sendo em cima de um objeto ao invés de um local disponível da tela. As demais são calculadas automaticamente, de acordo com as interações dos objetos com o mundo, como por colisões, movimentações ou alterações de gravidade.

%Além dessas propriedades, os objetos podem interagir entre si por meio de juntas, colisões ou motores adicionados aos objetos, que aplicam uma força constante sobre um objeto. As juntas são entidades que permite fixar um objeto a outro. Funciona, analogamente, a colocar um prego para juntar dois pedaços de madeira.
Além dessas propriedades, a cor dos objetos pode ser alterada pelo menu, bem como a gravidade do mundo. Também é possível a separação de mundos com gravidades diferentes e cores de pincéis diferentes entre si. O usuário ainda tem acesso a um apagador, para retirar do mundo qualquer objeto que não queira mais. Caso o usuário apague uma divisão entre mundos, os mundos continuam divididos e com suas propriedades diferentes, mas os objetos existentes em cada mundo podem transitar livremente entre os mundos unidos. A última propriedade disponível no menu é o \textit{Mute}, que pode ser selecionado para se desligar a música do jogo caso algum usuário deseje, ou ligar novamente caso esteja desligada.

As ferramentas e objetos disponíveis estão ilustradas na Figura~\ref{jogo}.

Neste \textit{software} interativo, não existem regras pré-definidas. Fica a critério do usuário definir suas regras enquanto interage com o \textit{software} criando cenários e objetos.

\subsection{Interface}
\label{cap5.1.4}
A interface utilizada para testes é a mesa cuja construção foi descrita no Capítulo~\ref{cap4}. Entretanto, salienta-se que o \textit{software Deskworld} é portável para qualquer interface multi-toque que suporte o protocolo \textit{TUIO}.

\section{Ferramentas de suporte}
\label{cap5.2}

Nesta seção, serão descritas as ferramentas de suporte, que fornecem aplicações reutilizáveis para facilitar o desenvolvimento de \textit{softwares}, utilizadas na construção do simulador \textit{Deskworld}, tais como game engine e bibliotecas.

\subsection{\textit{Game Engine}}
\label{cap5.2.1}

A \textit{engine} utilizada no desenvolvimento deste software foi a Box2D~[\citenum{Box2Dmanual}]. Esta engine é livre, ou seja, pode ser utilizada sem nenhum custo. A principal funcionalidade da \textit{Box2D}, no contexto desse \textit{software}, foi auxiliar na criação dos objetos e no tratamento de eventos relacionados à simulação das leis da física. Tais eventos são:

\begin{itemize}
	\item Gravidade
	\item Colisão
	\item Força de ação e reação
	\item Força de atrito
\end{itemize}

Além dessas funcionalidades, a \textit{Box2D} é responsável pela gerência de memória, junção de objetos e/ou a fixação deles. Sua escolha foi baseada em boa performace, simulação física de ambientes bidimensionais, além da estabilidade de seu código.

\subsection{\textit{Bibliotecas de apoio}}
\label{cap5.2.2}

Para facilitar a implementação do \textit{software}, foram utilizadas diversas bibliotecas. Uma das bibliotecas padrão do C++, a \textit{STL} \textit{(Standart Template Library)}, possui algumas estruturas complexas de dados já implementadas, sendo amplamente utilizada neste simulador. Para a parte gráfica do jogo foi utilizada a biblioteca \textit{SDL}~[\citenum{sdl}]  \textit{(Simple Direct Layer)} em conjunto com a \textit{OpenGL}~[\citenum{opengl}]  (\textit{Open Graphics Library}). Com relação ao áudio, utilizou-se a biblitoca \textit{SDL\_mixer}~[\citenum{sdlmixer}] . Para tratamento de \textit{input} foi utilizada a biblioteca do protocolo \textit{TUIO}~[\citenum{TUIO}] (\textit{Tangible User Interface System}) para receber as mensagens enviadas pelo \textit{CCV}~[\citenum{ccv}] (\textit{Community Core Vision}) explicado mais a frente.

\subsubsection{\textit{SDL} e \textit{OpenGL}}
\label{cap5.2.2.1}

Por oferecer uma boa abstração de \textit{hardware}, ser bem difundida no mercado de jogos e possuir ampla documentação, utilizou-se a \textit{SDL} para disponibilizar o acesso ao ambiente. Em conjunto com a \textit{SDL}, na parte gráfica, foi utilizada a \textit{OpenGL}, que realiza a renderização das imagens.

A \textit{SDL\_mixer} é utilizada para permitir a reprodução de diversas faixas de áudio simultaneamente.

\subsubsection{Protocolo \textit{TUIO}}
\label{cap5.2.2.2}

A comunicação entre o usuário da mesa e o aplicativo é realizada de acordo com o protocolo \textit{TUIO}~[\citenum{TUIO}]. Este protocolo é especificado para atender as necessidades de comunicação das interfaces tangíveis, que são interfaces sensíveis ao toque, capazes de serem controladas por movimentos corporais e gestos. A implementação é simples e visa melhorar a performance na comunicação. Para isso, ele opera sobre a camada \textit{UDP}(\textit{User Datagram Protocol}) de transporte utilizando três tipos de mensagens: \textit{set}, \textit{alive} e \textit{fseq}. As mensagens \textit{set} são utilizadas para informar o estado de um objeto. Mensagens \textit{alive} indicam o conjunto de objetos presentes na interface através de uma identificação única atribuída a cada novo elemento reconhecido. Mensagens \textit{fseq} são transmitidas antes da etapa de atualização de cada quadro, para marcá-lo unicamente, associando-o a cada mensagem \textit{set} e \textit{alive}. A seguir é apresentado um  resumo do funcionamento do protocolo:

\begin{itemize}
	\item Parâmetros do objeto são enviados após mudança de estado, por intermédio da mensagem \textit{set}.
	\item Objetos removidos da interface são comunicados por meio de mensagens \textit{alive}.
	\item Cliente deduz a lista de objetos adicionados e removido por meio das mensagens \textit{set} e \textit{alive}.
	\item Mensagens \textit{fseq} associam um ID a um conjunto de mensagens \textit{set} e \textit{alive} do quadro.
\end{itemize}

Apesar da camada UDP de transporte não oferecer garantia de entrega dos dados, o TUIO implementa redundância de informação para se precaver contra a perda de dados na transmissão. Além disso, o estado de um objeto, mesmo inalterado, é enviado periodicamente em uma mensagem \textit{set}. Portanto, o protocolo é adequado para ser utilizado em aplicativos controlados por interfaces multitoque, otimizando a interação e confiabilidade da comunicação. Na Tabela~\ref{tab:tabela1_param_TUIO}, pode-se observar todos os parâmetros que são enviados a cada mensagem do protocolo \textit{TUIO}. A posição, tal como vetor de movimento, aceleração, largura e altura do \textit{blob} são variáveis do tipo flutuante, pois o protocolo TUIO mapeia a tela a nível com valores entre 0 e 1.

\begin{table}[htbp]
  \centering
  	\caption{Parâmetros de mensagens TUIO em superfícies interativas 2D}
    \begin{tabular}{|l|l|l|} %rrr}
    \textbf{Parâmetros} & \textbf{Significado dos parâmetros} & \textbf{Tipo} \\
    s     & sessionID (ID temporário do objeto) & int32 \\
    x, y  & posição & float32 \\
    X, Y  & vetor de movimento (velocidade de movimento e direção) & float32 \\
    m     & aceleração de movimento & float32 \\
    w, h  & largura e altura do \textit{blob} & float32 \\
    \end{tabular}%
  \label{tab:tabela1_param_TUIO}%
\end{table}%

\subsubsection{\textit{Community Core Vision}}
\label{cap5.2.3}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.4]{ccv.jpg}
	\caption{Aplicativo de captura de toques \textit{Community Core Vision}~[\citenum{ccv}]}
	\label{ccv}
	\end{center}
\end{figure}

O \textit{CCV} (\textit{Community Core Vision})~[\citenum{ccv}] é um aplicativo para auxiliar no processamento de imagens capturadas pela câmera em interações com superfícies multi-toque. A Figura~\ref{ccv} apresenta um \textit{screenshot} do aplicativo. Ele lida com o acompanhamento dos \textit{blobs} de luz infravermelha, enviando mensagens para o \textit{Deskworld}, tais como o encostar do dedo, o deslocar do dedo e o retirar do dedo. Interage com a maioria dos dispositivos de captura de vídeo, sendo muito útil para um projeto de software que utilize uma mesa multitoque.  Atualmente, possui suporte para plataformas \textit{Windows} e \textit{Linux}, 32 ou 64 \textit{bits}, e \textit{MacOS}. Ele permite, por padrão, uma quantia máxima de 20 toques simultâneos, porém este número pode ser modificado em seu arquivo de configuração. Neste trabalho, foram testados até 30 toques ao mesmo tempo diretamente com a mesa, porém o valor de toques máximos possui a possibilidade de ser incrementado ainda mais.

Seu funcionamento consiste na aplicação de filtros configuráveis, como os mostrados na Figura~\ref{filtros} no capítulo anterior. Em seu arquivo de configuração, \textit{config.xml}, pode-se modificar os dados da câmera, tais como resolução e frames por segundo; o \textit{CCV} irá automaticamente ajustar a câmera selecionada para os dados mais próximos suportados. A execução do \textit{CCV} funciona de acordo com o paradigma cliente-servidor, onde o mesmo atua como servidor e a aplicação como cliente. Esta comunicação cliente-servidor é feita utilizando o protocolo TUIO~[\citenum{TUIO}] \textit{(Tangible User Interface System)}, utilizando pontos normais x e y enviados via \textit{TCP}, ou em pacotes especiais para aplicativos \textit{Flash}, permitindo uma arquitetura distribuída, onde o aplicativo é executado separadamente da aplicação de processamento de imagens.

\section{Arquitetura e Detalhes de Implementação}
\label{cap5.3}

A evolução da tecnologia dos \textit{hardwares} para computadores pessoais proporcionou grande desenvolvimento à indústria de jogos eletrônicos, levando-a a aprimorar seu produto ao longo do tempo. Este caminho foi marcado pela formação de grandes equipes e pela extensiva carga de codificação. Os jogos eletrônicos mais modernos podem ultrapassar um milhão de linhas de código de acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}]. Portanto, foi necessário organizar estes extensivos códigos a fim de obter um melhor desempenho no desenvolvimento de novos jogos. Esta organização pode ser realizada por meio da adoção de uma arquitetura bem definida.

\subsection{Arquitetura do \textit{Deskworld}}
\label{cap5.3.1}

Apesar de não se encaixar na definição de jogo eletrônico, o \textit{Deskworld} possui muitas características semelhantes, pois é um \textit{software} interativo, onde o usuário se relaciona com objetos em um mundo virtual. Dessa maneira, este \textit{software} foi desenvolvido a partir da utilização de um padrão de desenvolvimento voltado a jogos. Para este \textit{software} foi escolhida uma arquitetura modular orientada à objetos.

\subsubsection{Vantagens da abordagem orientada à objetos}
\label{cap5.3.1.1}

De acordo com \textit{Rabin et al.}~[\citenum{I2GMDVP}] a maioria dos jogos se desenvolvem em torno de objetos ou entidades em um mundo virtual, nos quais o usuário deve realizar ações. Antes da existência do paradigma da orientação a objetos, os jogos eram desenvolvidos com programação procedural e assim, a ênfase da programação baseava-se no código propriamente dito. Isto porque o jogo era observado, conceitualmente, como uma sequência de código com execução de procedimentos e funções. Na programação orientada à objetos, a perspectiva é outra, pois a ênfase ocorre no conceito de objeto que é uma coleção de informações conjuntas a uma série de operações para processar estes dados. Portanto, utilizando orientação à objetos é possível obter \textit{softwares} que se adequam ao formato dos jogos, pois as entidades desses jogos podem ser expressas pelas classes, os objetos por instâncias da classe e ações entre eles pelos métodos.

Outra vantagem encontrada nesta abordagem é a herança de classes, que permite a reutilização de código em múltiplas classes que possuam parentesco. Com herança, é possível estender características das superclasses para as subclasses. No \textit{Deskworld}, utilizou-se herança para, principalmente, padronizar e reutilizar parte do código dos \textit{Game Objects}. Também importante, o suporte ao polimorfismo é crucial no desenvolvimento de jogos já que permite a realização de \textit{update} e \textit{render} de diversos componentes do \textit{software} sem precisar separá-los em chamadas de execuções diferentes, pois todos serão reconhecidos pelo seu tipo e terão seus respectivos métodos executados corretamente.

A arquitetura do programa foi modularizada para especificar claramente os  seus subsistemas, facilitando a manutenção e o entendimento do código. No diagrama apresentado na Figura~\ref{diag-deskworld} pode ser observada a composição de módulos do \textit{Deskworld} e suas principais classes. A decomposição em módulos facilita a visualização da implementação, já que o \textit{software} possui subsistemas bem claramente definidos como os de áudio, vídeo, \textit{engine} e de \textit{input}.

\subsection{Detalhes de implementação}
\label{cap5.3.2}

Esta seção apresenta a lógica de implementação do \textit{software}. Primeiramente, é exposto uma visão geral do funcionamento do sistema. Em seguida, os subsistemas são detalhados e seus papéis traçados.

\subsubsection{Visão Geral do \textit{Software}}
\label{cap5.3.2.1}

Como observado no diagrama da Figura~\ref{diag-deskworld}, existe uma classe \textit{Game Manager} responsável pelo gerenciamento da execução do programa. Suas principais ações são inicializar os subsistemas de áudio, vídeo, carregar o cenário e inicializar a \textit{Engine} do \textit{Deskworld}. A classe áudio é responsável por carregar arquivos de áudio, bem como manipulá-los, podendo tocar, parar ou resumir um arquivo carregado. A \textit{Graphics} implementa soluções para renderizar os objetos na tela e gerenciar a memória de vídeo. O \textit{InputManager} trata as mensagens de entrada recebidas, explorados na Seção~\ref{cap5.2.2.2}, e gera eventos relativos aos toques. A \textit{Engine} tem como objetivo criar, alterar e posicionar objetos no mundo, além de se comunicar de posse destas informações  com a \textit{Box2D}. A classe \textit{LevelState} concentra o maior fluxo de informações, pois todas as instâncias de classe de objetos do mundo são criada nela. Os métodos de \textit{Update}, muito importante em simulações físicas, e \textit{Render} têm suas chamadas realizadas pelo \textit{LevelState}. O \textit{Game Object} armazena informações sobre os objetos como sua dimensão, posição e estado.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.666]{diagdeclasses.jpg}
	\caption{Diagrama de classes do \textit{Deskworld}}
	\label{diag-deskworld}
	\end{center}
\end{figure}

\subsubsection{Subsistemas de Áudio e Vídeo}
\label{cap5.3.2.2}

O subsistema de áudio possui atributos para identificar o nome do arquivo de áudio, o tipo do arquivo e um ponteiro para seu endereçamento na memória. Seu construtor carrega o arquivo de áudio para memória e retorna esse endereço ao ponteiro da classe. Utiliza-se esta classe para tocar e pausar a música de fundo. 

A classe \textit{Graphics} gerencia a memória de vídeo com a \textit{OpenGL}, e a utiliza para desenhar formas geométricas na tela. A classe \textit{ImageLoader} carrega imagens e texturas e renderiza-as. As texturas presentes no \textit{Software} são o fundo, menu e seus componentes.

\textbf{\textit{Singleton}}

A classe \textit{Graphics} é um \textit{Singleton}, isto é, possui, obrigatoriamente, apenas uma instância durante todo o programa. \textit{Singleton} é um \textit{design pattern}~[\citenum{gamma}] muito utilizado em situações que necessitam de grande controle sobre uma classe para que seja instanciada somente uma vez. Esta técnica consiste em declarar um construtor privado que será executado uma única vez. Constrói-se um método que retorna a instância única por meio de um ponteiro estático. Caso seja a primeira vez que é chamado, a classe é instanciada, caso contrário, retorna a instância já existente. Além desta, o \textit{InputManager} e a \textit{Engine} são singletons. Isto acontece porque todas essas classes só devem possuir somente uma instância, pois não se deseja várias instâncias controlando a saída de vídeo, a entrada de dados ou a simulação de objetos.

\subsubsection{Subsistema de \textit{Input}}
\label{cap5.3.2.3}

Neste subsistema, para dar suporte ao protocolo TUIO, tem-se a classe \textit{InputManager}, derivada da classe \textit{TuioListener}, que implementa métodos para escutar mensagens relativas à detecção de toques, gerando eventos. Estes eventos podem adicionar e remover toques ou atualizar suas posições. Também suporta a detecção de eventos de input via mouse ou teclado. O método principal da classe é o \textit{Update}, onde são percorridos todos os eventos enviados durante um \textit{Game Loop}, cada um sendo analisado e seus dados separados para utilização das outras classes. Por exemplo, caso seja adicionado um toque, o número identificador deste toque é salvo, permitindo que outra classe possa utilizá-lo por meio do método \textit{IsTouching}, de modo a descobrir se o toque com o identificador desejado está tocando ou não a superfície.

\subsubsection{Subsistema da \textit{Engine}}
\label{cap5.3.2.4}

A \textit{Engine} é composta pela classe \textit{Engine}, além do pacotes de classes da biblioteca \textit{Box2D}. Por intermédio destas classes, ocorre a criação dos objetos no mundo virtual. A simulação de gravidade, da força de atrito, e das forças de ação e reação, são calculadas pela \textit{Engine}. Um importante recurso para uma boa simulação é a detecção de colisão, tratada por esse subsistema. Também são realizadas operações de destruição de objetos, além da localização dos objetos ser atualizada e repassada aos outros módulos pela \textit{Engine}.

\subsubsection{Subsistema de gerência de objetos}
\label{cap5.3.2.5}

A classe \textit{LevelState} é responsável pelo único estado do \textit{software}. Estar no estado de \textit{LevelState} significa que o \textit{software} está em execução e o usuário pode interagir como desejar, criando objetos ou mudando propriedades. Nesta classe, todas as imagens que aparecem dentro do jogo são carregadas e renderizadas na tela. Seu método de \textit{Update}, chamado uma vez pelo \textit{Game Loop}, verifica todos os toques existentes ou removidos e decide o que cada um irá fazer, como por exemplo, criar um objeto novo, arrastar um objeto existente, abrir o menu ou alterar as opções. Seu outro método, \textit{Render}, é responsável por montar a tela do jogo, renderizando na tela todas as imagens em sua sequência, deixando-as prontas para serem mostradas na tela, assim que tudo estiver em posição.

A \textit{GameObject} é uma superclasse que agrega subclasses referentes a todos objetos presentes \textit{software}. Estas classes representam os objetos desenhados no programa que podem ser polígonos, círculos ou de forma livre. Além disso, objetos podem ser motores e juntas, explicadas no início deste capítulo. O próprio mundo do software é um objeto, pois podem existir vários mundos, e as próprias barreiras usadas para dividir os submundos também são consideradas objetos. Todos objetos possuem vértices que indicam suas posições e suas áreas. Todos os \textit{GameObject}s possuem métodos de \textit{Update} e \textit{Render}.